
给一个对列表项做适配的选择。

关于容器的使用：将几个相同的组件放在一起。

about list:

	just store data.not a plane.need an index to recover the plane before.

about notification:

	just support an singleton to store target and callback.

something is my job.something is not my job.I just do my job.

use the least codes to implementate a function

用户程序的本质就是一套“以计算机形式进行描述的用户事物处理方案”，这套方案要通过计算机的运算得到结果，而计算机的运算是由其主机部分完成的。可见，用户程序运行的最根本目的就是通过逐级对其处理问题的方案进行运算。

每一项数据都会有其特定的含义，关键是如何找出数据所关联的信息。

关于寻路的思考：
1.无碰撞体积寻路（点寻路）
2.有碰撞体积寻路->可以将障碍物扩大宽度，转化成点寻路。
3.动态寻路：只有两种处理方式
1).将动态物体当成静态来处理，不停寻路。
2).将动态物体独立处理。可在发生碰撞之后再当成静态物体。(记录动态物体块)

关于地图切分：
1.从头开始切分，记录每块切分后的地图。
2.障碍物块移除时，以切分障碍物的地图，对之后的障碍物重新切分。
3.障碍物添加时，添加到末尾，并切分。

关于编程：编程应该是考虑怎么把计算机操作转换成人类的操作，而不是把人类的操作转换成计算机操作。
一定要以人类的思维去构建结构，而不是以计算机的结构去构建。
修正版：把计算机的操作转换成人的操作所需要的复杂程度 和 把人的操作转换成计算机的操作的复杂程度 两者比较起来，选择简单的那个。一般情况下，把计算机的操作转换成人的操作会比较简单。但是涉及到很大的数量级的话，把人的操作转换成计算机的操作会简单。

对于一个问题，如果一个理论上的算法太过复杂，则很有必要去寻找近似算法，或者使用另外的理论去计算。比如划线算法。毕竟所谓的理论，不过是一种拟合。

关于分类：
1.分类是为了处理方便，所以分类的方式可以用处理方案来划分。
2.遇到一个对象，是否匹配现有的处理方案，若匹配，则加入，若不匹配，则重新创建一个处理方案，将其放入。
3.对于处理方案，也需要不停的优化，重新分组。
4.需要更多的思考关于分类的事情
5.分类会有一个目的，或者是为了实现功能，或者是为了理解。所以分类要从实际目的出发进行分类。

关于GTD:
1.虽然别人给出的定义步骤是：收集，整理，组织，回顾，执行。
2.但是个人觉得应该用：组织，收集，整理，回顾，执行。

关于控件：
1.多思考些逻辑控件。

关于设计：
1.之前认为的一个项目出现问题，认为是设计的问题，设计没有考虑到所有的细节，不过现在不那么认为了。设计本身就应该是富有富有创造性的，是上层的，而细节是底层的。细节的处理应该由底层框架来保证。正如人类应该把精力放在富有创造性的事情上，而那些繁杂的事情交给计算机来处理。
2.要避免繁杂的细节，唯一的方法就是看清楚事物的本质，将事物分解成有限个元本质，在将这些元本质重新排列组合成不同的事物。

关于c和c++的思考：
1.c和c++的设计初衷并不是完全一致的。所以两者的比较有很大程度上的限制。
2.c++提供了一些特性，对于设计上来说，简化了很多操作。而c不是。如果不用那些特性，c++和c也没有很大的差别。
3.个人觉得，程序员应该以设计为主。所以c++会比c更适用。

关于设计：
1.设计首先要考虑的应该是被设计的事物的特性，应该根据该事物的特性来给出特定的设计。
2.比如渲染，有很明显的特征。所以应该单独一个特定的渲染线程来处理，而不是用通用的逻辑线程来处理。

关于验收机制：
1.就是每个步骤的成果的验收。个人觉得蛮重要的。

关于主机子节序：
1.关于服务器和客户端子节序不同的问题。其实并不需要特地去做转变，完全可以布置两种类型的服务器来提供。

关于模块的功能：
1.一个模块实现一项功能，绝对不应该实现的是给自己安排任务这项功能。

关于网络交互：
1.客户端静态存储每个数据结构，每次标示一个uuid和需要更新的数据结构，服务器返回最新的数据和uuid。客户端更新，然后调用与uuid绑定的回调。

关于可扩展：
1.做每个模块的时候，首先要考虑的应该是这个模块需要扩展的可能性，如果扩展的可能性大于某个值，则需要编写可扩展的模块，如果可能性小于某个值，则没有必要去编写可扩展的代码。

关于活动策划案：
1. 活动必须得有个由头，有个目标，需要明确，通俗易懂，让人容易接受。（比如弄出点乱子，让玩家帮忙解决，然后给满意的报酬，最后各取所需）
2. 由头切记让人产生自我保护心理。不然就game over了。
3. 策划案的成败就在于这个由头了。是否让人容易接受。这是关键。


--<技术的本质>
关于技术：(--<技术的本质>)
1.技术，阿瑟指出，不是科学的副产品，而是或许恰好相反，科学是技术的副产品。

关于路径依赖性：
1.路径依赖性，阿瑟的论述，诺斯的论述，以及许多年前我的论述，可概括为这样一项平凡的陈述：人的行为依赖于他们过去的全部行为。注意，是依赖而不是由此被决定，也不是完全不依赖。

关于技术的理论：
1.技术都是某种组合。
2.技术的每个组件自身也是缩微的技术。
3.所有的技术都会利用或开发某种效应或现象。

关于技术的定义：
1.技术是实现人的目的一种手段。
2.技术是实践和元器件的集成。
3.技术是在某种文化中得以运用的装置和工程实践的集合。

关于数学家的工作：
1.首先需要准确界定术语，然后由此逻辑地导出结果和属性。

关于模块化：
1.将零件集成化可以更好地预防不可预知的变动，且更容易修复。
2.只有当模块被反复使用，且反复使用的次数足够多时，才值得付出代价将技术进行分割。

关于技术与现象：
1.新现象与新技术构成一个良性循环。新现象提供了发现新现象的新技术，或者说新技术发现了导致新技术的新现象。

关于稳定：
1.就像控制一架不稳定的双轮自行车要比控制一台三轮车更容易一样，控制一架内部不稳定的飞机要比控制内部稳定的飞机更容易。

以自展的方式解决复杂需求。

关于互联网主机的合理利用：
1.建立起一个隐藏的底层网络。
2.收集数据。
3.计算。

关于建立隐藏网络：
1.后台运行服务等待请求。
2.网络主机间的通信。

关于区块链技术的思考：
1.以多数来决定最终结果并非什么好的策略。容易产生群体暴政。因为多数的主机并没有什么好的防护措施。
2.层级结构或许是最好的方案。上级决策，下级执行。上级收到攻击可以联合下级进行抵御。

关于分类：
0.所有发生的事情，或者需要处理的事情都可以分为环境和操作。
1.环境作为第一分类标准。（优先按照环境划分）
2.逻辑操作作为第二分类标准。（场景的操作如果有重复，应该提取）
3.环境和构成环境的配件以及发生在环境中的操作，都可以统一看成是配件。组合起来就是一个完成的模块。
4.万物皆配件。

关于组合与继承：
1.继承能做到的事情，组合都可以做到。
2.不要再用继承了。

关于函数存放的位置：
1.一个处理事件的函数可以放在任意一个地方，只要给这个函数传入所需的所有数据。那么作为存放位置的最优选择，是以传入参数最少来判断吗？

关于效率：
1.所谓的效率其实就是收支比。实际收益和付出的比值。
2.程序的效率在于两方面。1.运行效率，2.实现效率。
