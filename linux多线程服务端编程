Linux多线程服务端编程使用muduo c++网络库


在面向对象程序设计中，对象的关系主要有三种：composition,aggregation,association.关系由强到弱
association是一般的关联。aggregation和composition都有整体和部分的关系，其中aggregation中的部分脱离了整体，部分仍然有意义，composition的部分脱离了整体，部分没有意义。

shared_ptr是引用计数型智能指针，weak_ptr也是一个引用计数型智能指针，但它不增加对象的引用次数。

c++内存问题大致有：
1.缓冲区溢出
2.空悬指针／野指针
3.重复释放
4.内存泄漏
5.不配对的new／delete
6.内存碎片

shared_ptr 本身不是线程安全的

条件变量：条件变量只有一种正确使用的方式。对于wait端：
1.必须与mutex一起使用，该布尔表达式的读写需受此mutex保护。
2.在mutex已上锁的时候才能调用wait()。
3.把判断布尔条件和wait()放到while循环中。（可能有spurious wakeup)

对于signal/broadcast端：
1.不一定要在mutex已上锁的情况下调用signal（理论上）
2.在signal之前一般要修改布尔表达式
3.修改布尔表达式通常要用mutex保护。
4.注意区分signal与broadcast

如果一个设计难以实现，应该首先要检讨设计。

提供灵活性固然是本事，然而在不需要灵活性的地方把代码写死，更需要大智慧。

copy_on_write:在read端，用一个栈上局部变量当作观察者，使引用计数＋1.对于write端，当g_foos.unique()为false，说明别的线程正在读取，不能原地修改，而是复制一份，在副本上修改。

有两种场合必须使用单线程：
1.程序可能会fork
2.限制程序的cpu占用率

线程不能减少工作量，即不能减少CPU事件。如果解决一个问题需要执行一亿条指令，那么多线程只会让这个数字增加。

学习多线程编程面临的最大的思维方式的转变有两点：
1.当前线程可能随时会被切换出去。
2.多线程程序中事件的发生顺序不再有全局统一的先后关系。

程序中出现pthread_{cancel,kill}，则通常意味着设计出了问题。

内存模型：从理论上讲，如果没有合适的内存模型，编写正确的多线程程序属于撞大运行为。

gdb通过一个系统调用ptrace来接管程序。
#include<sys/ptrace.h>
int ptrace(int request, int pid, int addr, int data)

线程是稀缺资源，一个进程可以创建的并发线程数目受限于地址空间的大小和内核参数，一台机器可以同时并行运行的线程数目受限于CPU的数目。因此我们在设计一个服务端程序的时候要精心规划线程的数目，特别是根据机器的CPU数目来设置工作线程的数目，并为关键人物保留足够的计算资源。

不要为了每个计算任务，每次请求去创建线程。一般也不会为每个网络连接创建线程，除非并发连接数与CPU数相近。一个服务程序的线程数目应该与当前负载无关，而应该与机器的CPU数目有关，即load average有比较小的上限。

任何从外部强行终止线程的做法和想法都是错的。

函数互相调用产生死锁。

getdayoftime 获得微秒级时间，不会陷入内核

生产者，消费者类型问题肯定都会存在一个最佳比例，按照每台机器的配置确定比例就可以了。

要量体裁衣，为问题制订合身的解决方案。

解决问题不一定就是要完全避免问题出现，也可以是问题出现了之后的应对。
避免使用continue和break。程序是要告诉计算机需要做什么，而不是不要做什么。

用清晰的代码表达程序猿的意图，让编译器容易实施优化。
 一旦要考虑扩展，什么办法都没用，还不如把程序写简单点，将来好大改或重写。

我想其实不管是计算机科学还是其他科学，都应该是面向概念的吧。
当现有的概念无法表达的时候，就是到了该打碎现有概念进行重组的时候了。

impl技法

早期C语言甚至不允许在不同struct中使用相同的成员名称，因此我们看到一些struct的名字有前缀，例如struct sockaddr_in的成员是sin_family

语法层面的错误往往预示着语意层面的错误。
