

λ演算形式化：
<expr> ::= <identifier>
<expr> ::= (λ <identifier> . <expr>)
<expr> ::=(<expr> <expr>)

头两条规则用来生成函数，第三条描述了函数是如何作用在参数上的。

仿函数（functor），就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为。

C语言使用函数指针和回调函数来实现仿函数。

C++通过重载括号运算符的方法使用一个函数对象而不是一个普通函数。

一般而言纯虚函数的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数变为虚函数），这一点经常被人们忽视，调用纯虚函数的方法为baseclass::virtual function.

线程同步的四项原则：
1.首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑immutable对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。
2.其次是使用高级的并发编程构件。
3.最后不得已必须使用底层同步原语时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。
4.除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”。

只用非递归的互斥器：如果外层代码已经拿到了锁，正在修改，内层代码又尝试锁的时候，使用递归互斥器不容易找到错误。

assert是用来避免显而易见的错误的，而不是处理异常的。错误和异常是不一样的，错误是不应该出现的，异常是不可避免的。
一个非常简单的使用assert的规律就是，在方法或者函数的最开始使用，如果在方法的中间使用则需要慎重考虑是否是应该的。方法的最开始还没开始一个功能过程，在一个功能过程执行中出现的问题几乎都是异常。
使用assert时，可以不用额外的防错设计。

static_assert:这个宏用于检测盒诊断编译时错误。用于检测编译时程序的不变量。

赋值函数比构造函数复杂的多，分四步实现：
1.检查自赋值。可能会出现间接赋值，且在赋值的时候可能会出现先释放，再重新申请的情况，会出错。
2.释放原有的内存资源。如果现在不释放，以后就没机会了，会造成内存泄漏。
3.分配新的内存。
4.返回本对象的引用

c++编译器会默认生成构造函数，析构函数，拷贝构造函数和赋值函数
c++中，一个参数的构造函数（或者除了第一个参数外其余参数都有默认值的多参构造函数），承担两个角色。1.是个构造器，2.是个默认且隐含的类型转换操作符。使用explicit防止隐式转换。

线程是珍贵的共享资源，不能轻易浪费（阻塞也是浪费）。
等待某个事件发生，正确的做法是使用select等价物或condition，抑或高层同步工具；

std::map 下标操作。只有当map中有这个键的实例时才对，否则会自动插入一个实例，值为初始化值。
可以用find和count来发现一个键是否存在。find获得的是iterator类型，是一个std::pair对象。

带一个参数的构造函数可以进行类型转换，但这样的转换功能受到限制。因此需要引入一种特殊的成员函数：类型转换函数，他在类对象之间提供一种类似显示类型转换的机制。格式：
Class_name::operator type()
{
	...
	return (type类型实例）
}

 很久以前，没有办法区分++和--操作符的前缀和后缀调用。这个问题遭到程序猿的抱怨，于是c++语言得到了扩展，允许重载increment和decrement操作符的两种形式。为了解决这个语言问题，c++规定后缀形式有一个int类型参数，当函数被调用时，编译器传递一个0做为int参数的值给该函数。
++i;//调用i.operator++();
i++;//调用i.operator++(0);




