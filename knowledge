

λ演算形式化：
<expr> ::= <identifier>
<expr> ::= (λ <identifier> . <expr>)
<expr> ::=(<expr> <expr>)

头两条规则用来生成函数，第三条描述了函数是如何作用在参数上的。

仿函数（functor），就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为。

C语言使用函数指针和回调函数来实现仿函数。

C++通过重载括号运算符的方法使用一个函数对象而不是一个普通函数。

一般而言纯虚函数的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数变为虚函数），这一点经常被人们忽视，调用纯虚函数的方法为baseclass::virtual function.

线程同步的四项原则：
1.首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑immutable对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。
2.其次是使用高级的并发编程构件。
3.最后不得已必须使用底层同步原语时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。
4.除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”。

只用非递归的互斥器：如果外层代码已经拿到了锁，正在修改，内层代码又尝试锁的时候，使用递归互斥器不容易找到错误。

assert是用来避免显而易见的错误的，而不是处理异常的。错误和异常是不一样的，错误是不应该出现的，异常是不可避免的。
一个非常简单的使用assert的规律就是，在方法或者函数的最开始使用，如果在方法的中间使用则需要慎重考虑是否是应该的。方法的最开始还没开始一个功能过程，在一个功能过程执行中出现的问题几乎都是异常。
使用assert时，可以不用额外的防错设计。

static_assert:这个宏用于检测盒诊断编译时错误。用于检测编译时程序的不变量。

赋值函数比构造函数复杂的多，分四步实现：
1.检查自赋值。可能会出现间接赋值，且在赋值的时候可能会出现先释放，再重新申请的情况，会出错。
2.释放原有的内存资源。如果现在不释放，以后就没机会了，会造成内存泄漏。
3.分配新的内存。
4.返回本对象的引用

c++编译器会默认生成构造函数，析构函数，拷贝构造函数和赋值函数
c++中，一个参数的构造函数（或者除了第一个参数外其余参数都有默认值的多参构造函数），承担两个角色。1.是个构造器，2.是个默认且隐含的类型转换操作符。使用explicit防止隐式转换。

线程是珍贵的共享资源，不能轻易浪费（阻塞也是浪费）。
等待某个事件发生，正确的做法是使用select等价物或condition，抑或高层同步工具；

std::map 下标操作。只有当map中有这个键的实例时才对，否则会自动插入一个实例，值为初始化值。
可以用find和count来发现一个键是否存在。find获得的是iterator类型，是一个std::pair对象。

带一个参数的构造函数可以进行类型转换，但这样的转换功能受到限制。因此需要引入一种特殊的成员函数：类型转换函数，他在类对象之间提供一种类似显示类型转换的机制。格式：
Class_name::operator type()
{
	...
	return (type类型实例）
}

 很久以前，没有办法区分++和--操作符的前缀和后缀调用。这个问题遭到程序猿的抱怨，于是c++语言得到了扩展，允许重载increment和decrement操作符的两种形式。为了解决这个语言问题，c++规定后缀形式有一个int类型参数，当函数被调用时，编译器传递一个0做为int参数的值给该函数。
++i;//调用i.operator++();
i++;//调用i.operator++(0);

要达到一个目标，你必须清楚的看到以下几个要素：
1.所追求的目标的本质
2.达到目标所具有的意义
3.现有的条件
4.从现有的条件到达目标，切实可行的路线
5.前进道路上可能遇到的问题，以及解决他们的计划

每个推理或者说解决方案都是有假设的，如果假设基本满足解决方案所作出的假设，那么那个解决方案就是有效的，如果假设不满足那么解决方案就是无效的。
因此要学习使用一种解决方案，首先必须弄清楚他的适用范围。

原来自己一直都在本末倒置。

c标准中的一些预定义宏：
__DATE__ 进行预处理的日期
__FILE__代表当前源代码文件名的字符串文字，包含了详细路径
__LINE__代表当前源代码中的行号的整数常量
__TIME__源文件编译时间
__func__当前所在函数名，在编译器的较高版本中支持
__FUNCTION__当前所在函数名

表述的简单，理解就会困难，表述的详尽，理解就会简单
王垠之所以会主张以简单的形式写代码，是因为他站在一个学者的角度，以让别人明白优先。
c++沉思录的作者主张以简单的形式写，是站在一个使用者的角度，以做出东西来优先。
个人以为，代码的首要目的是实现一个功能和想法，而不是让别人明白。让别人明白和理解是学校老师该做的事情。所以结论是，我觉得以简单的形式，使用方便为优先考虑，其次才是易懂性。

或许每当出现相互引用的地方，都可以考虑把两个相互引用的对象合并成一个对象。

可以初始化const对象或引用类型的对象，但不能对他们赋值。在开始执行构造函数的函数体之前，要完成初始化。初始化const或引用类型数据成员的唯一机会是构造函数初始化列表中。

左值就是表达式结束时还会存在的对象，右值就是表达式结束时不会存在的对象。

从使用上来讲，闭包用起来就像是个函数样板，其中保留了一些可以在稍后再填入的空格。

类型：规定了变量可以取的值的范围，以及该类型的值可以进行的操作。根据类型的值的可赋值状况，可以把类型分为三类：
1.first class。该等级的值可以传给子程序作为参数，可以从子程序里返回，可以赋给变量。大多数程序设计语言里，整型，字符类型等简单类型都是一级的。
2.second class。该等级类型的值可以传给子程序作为参数，但是不能从子程序里返回，也不能赋值给变量。
3.third class。该等级类型的值连作为参数传递也不行。

临时变量：临时变量不是我们自己临时创建的变量，而是编译器在编译时候自动生成的变量。
