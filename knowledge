

λ演算形式化：
<expr> ::= <identifier>
<expr> ::= (λ <identifier> . <expr>)
<expr> ::=(<expr> <expr>)

头两条规则用来生成函数，第三条描述了函数是如何作用在参数上的。

仿函数（functor），就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为。

C语言使用函数指针和回调函数来实现仿函数。

C++通过重载括号运算符的方法使用一个函数对象而不是一个普通函数。

一般而言纯虚函数的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数变为虚函数），这一点经常被人们忽视，调用纯虚函数的方法为baseclass::virtual function.

线程同步的四项原则：
1.首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑immutable对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。
2.其次是使用高级的并发编程构件。
3.最后不得已必须使用底层同步原语时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。
4.除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”。

只用非递归的互斥器：如果外层代码已经拿到了锁，正在修改，内层代码又尝试锁的时候，使用递归互斥器不容易找到错误。

assert是用来避免显而易见的错误的，而不是处理异常的。错误和异常是不一样的，错误是不应该出现的，异常是不可避免的。
一个非常简单的使用assert的规律就是，在方法或者函数的最开始使用，如果在方法的中间使用则需要慎重考虑是否是应该的。方法的最开始还没开始一个功能过程，在一个功能过程执行中出现的问题几乎都是异常。
使用assert时，可以不用额外的防错设计。

static_assert:这个宏用于检测盒诊断编译时错误。用于检测编译时程序的不变量。

赋值函数比构造函数复杂的多，分四步实现：
1.检查自赋值。可能会出现间接赋值，且在赋值的时候可能会出现先释放，再重新申请的情况，会出错。
2.释放原有的内存资源。如果现在不释放，以后就没机会了，会造成内存泄漏。
3.分配新的内存。
4.返回本对象的引用

c++编译器会默认生成构造函数，析构函数，拷贝构造函数和赋值函数
c++中，一个参数的构造函数（或者除了第一个参数外其余参数都有默认值的多参构造函数），承担两个角色。1.是个构造器，2.是个默认且隐含的类型转换操作符。使用explicit防止隐式转换。

线程是珍贵的共享资源，不能轻易浪费（阻塞也是浪费）。
等待某个事件发生，正确的做法是使用select等价物或condition，抑或高层同步工具；

std::map 下标操作。只有当map中有这个键的实例时才对，否则会自动插入一个实例，值为初始化值。
可以用find和count来发现一个键是否存在。find获得的是iterator类型，是一个std::pair对象。

带一个参数的构造函数可以进行类型转换，但这样的转换功能受到限制。因此需要引入一种特殊的成员函数：类型转换函数，他在类对象之间提供一种类似显示类型转换的机制。格式：
Class_name::operator type()
{
	...
	return (type类型实例）
}

 很久以前，没有办法区分++和--操作符的前缀和后缀调用。这个问题遭到程序猿的抱怨，于是c++语言得到了扩展，允许重载increment和decrement操作符的两种形式。为了解决这个语言问题，c++规定后缀形式有一个int类型参数，当函数被调用时，编译器传递一个0做为int参数的值给该函数。
++i;//调用i.operator++();
i++;//调用i.operator++(0);

要达到一个目标，你必须清楚的看到以下几个要素：
1.所追求的目标的本质
2.达到目标所具有的意义
3.现有的条件
4.从现有的条件到达目标，切实可行的路线
5.前进道路上可能遇到的问题，以及解决他们的计划

每个推理或者说解决方案都是有假设的，如果假设基本满足解决方案所作出的假设，那么那个解决方案就是有效的，如果假设不满足那么解决方案就是无效的。
因此要学习使用一种解决方案，首先必须弄清楚他的适用范围。

原来自己一直都在本末倒置。

c标准中的一些预定义宏：
__DATE__ 进行预处理的日期
__FILE__代表当前源代码文件名的字符串文字，包含了详细路径
__LINE__代表当前源代码中的行号的整数常量
__TIME__源文件编译时间
__func__当前所在函数名，在编译器的较高版本中支持
__FUNCTION__当前所在函数名

表述的简单，理解就会困难，表述的详尽，理解就会简单
王垠之所以会主张以简单的形式写代码，是因为他站在一个学者的角度，以让别人明白优先。
c++沉思录的作者主张以简单的形式写，是站在一个使用者的角度，以做出东西来优先。
个人以为，代码的首要目的是实现一个功能和想法，而不是让别人明白。让别人明白和理解是学校老师该做的事情。所以结论是，我觉得以简单的形式，使用方便为优先考虑，其次才是易懂性。

或许每当出现相互引用的地方，都可以考虑把两个相互引用的对象合并成一个对象。

可以初始化const对象或引用类型的对象，但不能对他们赋值。在开始执行构造函数的函数体之前，要完成初始化。初始化const或引用类型数据成员的唯一机会是构造函数初始化列表中。

左值就是表达式结束时还会存在的对象，右值就是表达式结束时不会存在的对象。

从使用上来讲，闭包用起来就像是个函数样板，其中保留了一些可以在稍后再填入的空格。

类型：规定了变量可以取的值的范围，以及该类型的值可以进行的操作。根据类型的值的可赋值状况，可以把类型分为三类：
1.first class。该等级的值可以传给子程序作为参数，可以从子程序里返回，可以赋给变量。大多数程序设计语言里，整型，字符类型等简单类型都是一级的。
2.second class。该等级类型的值可以传给子程序作为参数，但是不能从子程序里返回，也不能赋值给变量。
3.third class。该等级类型的值连作为参数传递也不行。

临时变量：临时变量不是我们自己临时创建的变量，而是编译器在编译时候自动生成的变量。

关于区块链技术：
建立在分布式存储的基础上。用多个副本来校验。

关于设计：
1.设计是为构建有意义的秩序而付出的有意识地直觉上的努力。
第一步：理解用户的期望，需求，动机，并理解业务，技术和行业上的需求和限制。
第二步：将这些所知道的东西转化为对产品的规划（或者产品本身），使得产品的形式，内容和行为变得有用，能用，令人向往，并且在经济和技术上可行。

关于设计方法：
1.KISS原则（保持简单愚蠢的），努力消除不必要的并发症。
2.有一个以上的方式来做到这一点，一种哲学，以允许许多个方法做同样的事情。
3.使用为中心的设计，这主要与使用的神器，而不是着眼于最终用户的目标和任务。

关于设计原则：
1.单一职责原则：一个类，最好只做一件事，只有一个引起它变化的原因。
2.开放-封闭原则：软件实体应该是可以扩展的，但是不可修改的。
3.依赖倒转原则：这个原则的内容是：要依赖于抽象，不要依赖于具体。或者说是：要针对接口编程，不要对实现编程。高层模块不应该依赖底层模块，两个都应该依赖抽象。
4.里氏代换原则：在一个软件系统中，子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。
5.迪米特原则：最少知识原则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的方法的话，可以通过第三者转发这个调用。

关于工程控制论：
1.工程控制论的目的是把工程实践中所经常运用的设计原则和试验方法加以整理和总结，取其共性，提高成科学理论，使科学技术人员获得更广阔的眼界，用更系统的方法去观察技术问题，去指导千差万别的工程实践。

关于程序设计：
1.程序里面不需要转换器这个概念。转换直接由构造来完成。
2.所有结果都可以由特定的对象得到。而所有特定的对象之间有转换关系，所以给定一些对象之后，可以由最短路劲算法得到结论。
3.程序里面不需要单例这个概念。直接由静态成员来实现。
4.遵循谁创建，谁管理的准则。

关于编译器：
1.有这么一种想法，将多个方法放在一起组成一个模块，多个模块可有相同的方法，在调用的时候，按照记录的模块号来调用方法。
