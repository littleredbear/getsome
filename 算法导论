

信息的表示与处理永远是计算技术永恒的主题.信息处理的核心是算法.

如果一个算法的行为不仅由其输入决定，还要由一个随机数生成器的值来决定，那么它就是一个随机化算法。
非形式地说，算法就是任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样算法就是把输入转换成输出的计算步骤的一个序列。

算法就是如何把输入转换成输出，但是也仅仅是这样。输入到输出应该对应到具体的概念，物理用物理的理论做转换，数学用数学的理论做转换。所以，个人认为其实算法并没有需要单独出来研究的必要。但是把这些所有的东西再统一用算法这个概念来指代，或许是有其意义的，仅仅从整个程序上来考虑的话，可以准确划分程序的结构。
或许所有的程序都可以由一种元素构成：算法？？？可以吗？不可以吗？

如果说这个世界上的所有问题都是由几种基本元素构成的话，那么那些基本元素到底是什么呢？？？其实也就是构成物质的那些基本元素。哈哈哈。。。

数据结构是一种存储和组织数据的方式，旨在便于访问和修改。

计算机也许是快的，但它们不是无限快。存储器也许是廉价的，但不是免费的。所以计算时间是一种有限资源，存储器中的空间也一样。你应该明智地使用这些资源，在时间或空间方面有效的算法将帮助你这样使用资源。

为求解相同问题而设计的不同算法在效率方面常常具有显著的差别。这些差别可能比由于硬件和软件造成的差别重要的多。

关于排序或者排序相关的算法，就是将所有的对象分配到所有状态(关系/属性)中，再在每个状态中执行相同的操作。
排序之所以用分治法比用增量法快，是因为取增量这个步骤要花费n个计算步骤，如果能直接取出来，那么增量法快。

θ记号渐近地给出一个函数的上界和下界。
当只有一个渐近上界时，使用O记号。
当只有一个渐近下界时，使用Ω记号。

θ(g(n)) = {f(n):存在正常量c1,c2和n0,使得对所有n>=n0,有0<=c1g(n)<=f(n)<=c2g(n)}
O(g(n)) = {f(n):存在正常量c和n0，使得对所有n>=n0,有0<=f(n)<=cg(n)}
Ω(g(n)) = {f(n):存在正常量c和n0,使得对所有n>=n0,有0<=cg(n)<=f(n)}
o(g(n)) = {f(n):对任意正常量c>0,存在常量n0>0,使得对所有n>=n0,有0<=f(n)<cg(n)}

二项树Bk是一种递归定义的有序树。二项树B0只包含一个结点。二项树Bk由两个子树Bk-1连接而成，其中一棵树的根是另一棵树的根的最左孩子。
二项堆H由一组二项树构成，但需要满足下面两个性质：
1.H中的每个二项树遵循最小堆的性质；结点的关键字大于等于其父结点的关键字。
2.对于任意非负整数k，在H中至多有一棵二项树的根具有度数k。

算法设计技术：
1.增量方法，
2.分治法
3.动态规划
4.贪心算法
