
计算机的世界里面只有一种东西，那就是广义上的数据。再细分可以分为指令和数据。而对象编程和函数编程都是组织指令和数据的方式。

pthread并非Linux系统的默认库，而是POSIX线程库。在Linux中将其作为一个库来使用，因此加上-lpthread以显式链接该库。

pthread面向对象封装：
class Thread {
	void start() {
		pthread_create(&thread_id, NULL, ThreadFunc, this);
	};

	static void * ThreadFunc (void *pth) {
		Thread *p = static_cast<Thread *>(pth);
		p->Run();
	};

	virtual void Run() = 0;	

};


关于线程
读写模型：
1.一个线程负责修改数据，一个线程使用数据，使用数据的线程标记已经使用的数据，修改数据的线程负责删除已经使用的数据，添加新的数据。
2.一个线程标记需要处理的数据，一个线程处理数据，标记处理完成的数据，再另一个线程取出数据，再标记自己的标记
3.只要每个线程分配到的数据没有交集，就可以了。而且这也是比处理线程同步更经济的方法。切勿越俎代庖。
4.多线程如果不是函数式编程，那么更多的应该考虑的是逻辑上的切分，没有交集.以函数作为对象进行交互。比如创建和摧毁都以函数接口的形式来实现。简单来说，就是不要使用引用语义，只使用值语义。以为函数式编程只有值语义，所以不需要特别处理。

关于线程的一个猜想：
1.线程的限制是只能有一个线程同时处理一块内存。所以在编译的时候，对内存进行线程分配，这样就可以了。

二段式构造：在构造函数内不能泄露this指针，会线程不安全。别的线程可能会访问这个半成品对象。

core dump:核心转储。当进程发生错误或收到信号而终止执行时，系统会将核心映像写入一个文件。
core image：核心映像，就是进程执行当时的内存内容。

一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较mutex对象的地址，始终先加锁地址较小的mutex。

值语义：所谓值语义是指目标对象由源对象拷贝生成，且生成后与源对象完全无关。就像int类型变量相互拷贝一样。
对象语义：也叫指针语义，引用语义等。通常指一个目标对象由源对象拷贝生成，但生成后与源对象之间依然共享底层资源。

EventLoop:包含一个normalChannel，一个bandChannel，一个Poller。
EventCenter(ThreadPool):控制所有的Thread，分发Event，（在Event调用过程中可以在其他线程处理的Event，尽量把Event细分，在Event调用栈里面，使用ThreadPool来分发任务）

关于多线程：
1.多线程的本质就是差异性。所以多线程要在设计上分配好任务。让每个线程处理不同的任务，而不是相同的任务。
2.而让多线程处理相同的任务。这个不是多线程的考虑范围内，应该由另外的一个模块进行任务分类。

关于IPv6常见地址：
1).  ::/128  即0:0:0:0:0:0:0:0，只能作为尚未获得正式地址的主机的源地址，不能作为目的地址，不能分配给真实的网络接口。
2).  ::1/128 即0:0:0:0:0:0:0:1，回环地址，相当于IPv4中的localhost（127.0.0.1），ping locahost可得到此地址。
3).  2001::/16  全球可聚合地址，由 IANA 按地域和ISP进行分配，是最常用的IPv6地址，属于单播地址。
4).  2002::/16  6 to 4 地址，用于6to4自动构造隧道技术的地址，属于单播地址。
5).  3ffe::/16　 早期开始的IPv6 6bone试验网 地址，属于单播地址。
6).  fe80::/10　 本地链路地址，用于单一链路，适用于自动配置、邻机发现等，路由器不转发以fe80开头的地址。
7).  ff00::/8  组播地址。
8).  ::A.B.C.D  兼容IPv4的IPv6地址，其中代表IPv4地址。自动将IPv6包以隧道方式在IPv4网络中传送的IPv4/IPv6节点将使用这些地址。
9).  ::FFFF:A.B.C.D　 是IPv4映射过来的IPv6地址，其中代表IPv4地址，例如 ::ffff:202.120.2.30 ，它是在不支持IPv6的网上用于表示IPv4节点。

关于数据和功能：
1. 所有的编程工作的本质是数据和功能
2. 编程唯一需要注意的是将数据和功能分离，相互独立。
3. 最后任一结果可以由有限个现有的数据和功能的线性组合得到。

