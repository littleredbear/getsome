
对外的使用接口要尽量简单。

C++11 将POD划分为两个基本概念的集合（只有满足这两个基本概念才能成为POD类型）：
1.平凡的（trivial）：平凡的构造函数，析构函数，复制构造函数，赋值操作符，不能包含虚函数，虚基类
2.标准布局的（standard layout）所有非静态成员都有相同的访问权限


c++最基本的设计理念是“用类来表示概念”，c++解决复杂性的基本原则就是抽象。 抽象是有选择的忽略

c++和c的最大区别就是存储状态,使得对系统的改变容易

我想做的事情是，使程序员们能更简单地把自己的工作发布到不断增加的机器中。（更简单！！！）

我被c++吸引住，很大程度上是由于数据抽象，而不是面向对象编程。c++允许我定义数据结构的属性，还允许我在用到这些数据结构时，把它们当做黑匣子使用。

我考虑问题的本质是什么，再定义一个类来抓住这个本质，并确保这个类能独立地工作。然后在遇到符合这个本质的问题时就使用这个类。

车和编程语言都是工具。它们可能极具艺术魅力，但是本质上车时交通工具，编程语言是写程序的工具，归结起来都是解决问题的工具。通常我们不可能为特定的工具挑选合适的问题。

我一般不提OOP，但只要提到，我的意思就是指使用继承和动态绑定的编程方式。
继承是一种抽象，它允许程序员在某些时候忽略相似对象间的差异，又在其他时候利用这些差异。

对象的创建和复制不是运行时多态的。如果有一系列类之间存在继承关系，当我们需要创建，复制和存储对象，而这些对象的确切类型只有到运行时才能知道时，这种编译时的检查会带来一些麻烦。

句柄类：智能指针

用函数来实现访问:
即使类Vector的设计者想允许用户改变Vector的长度，把长度当做一个公共数据成员也不是个好办法。和复制Vector的值一样，改变长度大致上也需要自动的分配和回收内存。如果长度是一个由用户直接设置的变量，就无法马上检测到用户所做的改变。所以对这种改变总是滞后的，很可能是在每次对Vector进行操作之前才检测刚才的操作有没有改变长度。而如果使用成员函数，用户只能通过调用函数来改变Vector的长度，这样一来用户每次改变长度，我们都心知肚明。

构造函数的用途就是用一种明确定义的状态来设置对象。对象的状态由对象的数据成员进行反映。因此，每个构造函数都要负责为所有的数据成员设置经过明确定义的值。如果构造函数没有做到这一点，就很可能导致错误。

使所有的类都自动包含虚析构函数会亵渎c++“只为用到的东西付出代价”的哲学。

类设计者的核查表：
1.你的类需要一个构造函数吗？
2.你的数据成员是私有的吗？
3.你的类需要一个无参的构造函数吗？
4.是不是每个构造函数初始化所有的数据成员？
5.类需要析构函数吗？
6.类需要虚析构函数吗？
7.你的类需要复制构造函数吗？
8.你的类需要一个赋值操作符吗？
9.你的赋值操作符能正确地将对象赋给对象本身吗？
10.你的类需要定义关系操作符吗？
11.删除数组时你记住了用delete[]吗？
12.记得在复制构造函数和赋值操作符的参数类型中加上了const了吗？
13.如果函数由引用参数，它们应该是const引用吗？
14.记得适当地声明成员函数为const的了吗？

对于智能指针可以直接调用operator->：Point ＊addr ＝ h.operator->();从而获得底层Point对象的地址。

引用计数不能是句柄的一部分。如果这么干，那么每一个句柄都必须知道跟它一起被绑定到同一个对象的其它所有句柄的位置。(这里可能没有把引用计数当做一个对象作为成员，而引用计数放在对象里面，可以直接修改吧？？？）当然也可以是把计数放在原来Point里面


当需要用到一个类型字段的时候，请停下来，考虑如果定义一系列类，用继承组织起来，是否可以更有效地解决问题。

p.80 由于Expr构造函数为Expr_node分配了内存，我们需要实现复制构造函数和赋值操作符管理下层的Expr_node。如果Expr的析构函数销毁了所指向的对象，那么在复制或赋值一个Expr时就需要生成该对象的一个副本。不过在写代码前，首先应该考虑我们是否真的需要复制操作。避免复制的常用办法是让每一个Expr_node包含一个引用计数，指明同时有多少Expr指向同一个Expr_node。

再反思一下我们必须做什么，还有，也许更重要的是，不必做什么。增加一个新的操作无须触及已有的代码。

我们已经看到了面向对象编程是如何简化程序的设计和更新过程的。解决方案的实质是要对希望模拟的下层系统中的对象进行建模。

p.91 问题本身并没有告诉我们这些操作应当具有怎样的形式。通常，对于这种细节的考虑正是寻求解决方案的开端。要想决定具体操作的形式，有一个好办法，就是试着使用这些操作。从使用的例子中推导出操作的定义形式要比从头苦思冥想地发明这些操作容易得多。

p.102 如果我们要写一个函数，把有边框的图像的边框去掉，在这个设计方案里，我们根本无法区分真正的边框和恰好像是边框的字符，所以根本写不出这个函数。这些不足之处是因为：我们实现了Picture类来存储一个图像的“表象”，却没有存储其结构。

p.119 在解决问题的时候，有一点要始终牢记，不仅要看到眼前的问题，还要看到长远的变化。在这个特定的问题里，最重要的一个认识是，图像是有结构的，总有一天我们会考虑到这些结构。而这种认识使我们不仅仅存储所产生的图像内容，而是主动想办法存储这些结构。

在实际开发中，灵活性通常是有意义的，因为它使我们面对需求的变更不至于一切推翻重来。至于应当为这种灵活性付出多大代价，当然有一个工程上的权衡问题，只能根据对环境的理解来做出回答。

如果我花时间考虑其他人将如何扩展这个类的话，就会占用本来应该花在其他设计上的时间。我不知道提供这样一个类会使谁的生活更轻松。
虚函数和非虚函数之间的区别只有下面这种特定的环境下才会体现出来：当使用一个基类指针或引用一个派生类对象时。
虚函数是c++的基本组成部分，也是面向对象编程所必需的。然而，即使是一个有用的东西，我们也应该考虑使用的合适时机。

从某种意义上说，模版只不过是语法宏的一种受限形式。
用另一种方式看待模版更有趣，就是把它们当做编译期函数－以类型作为参数并产生代码。

就像我们对类所做的事情一样，我们必须决定要支持哪些操作。
通常，弄清楚想利用容器做什么是很重要的。

p.148 它告诉给用户太多关于它内部运作的信息，以至于违背了封装的概念。

通常，设计者先考虑怎样的操作或者特性是有用的，然后才考虑实现的问题。

我们怎样安排才能使得删除Array时不会真正使Array消失？解决这类问题的方法就是运用我经常称为“软件工程基本定理”的思想：通过引进一个额外的中间层，我们能够解决任何问题。如果想在删除了Array对象后仍然保留数据，就可以运用这个定理，即让Array指向数据而不是包含数据。

如果你知道不会去使用那些为定义的行为，而且也不会让别人使用你的类，那么就高枕无忧了。如果最终自己还是要用到它，你的程序就可能做你没有预料到的事情，此时你就不得不找出它为什么要这样做。与在开始就定义操作相比，调试对为定义操作的不经意的使用要麻烦得多。

成功建立任何一个大规模系统的关键在于将它划分成可以独立处理的小模块。然而，关键的关键就是在这些小模块之间定义清晰的接口。
这里的指导思想是考虑这个应用想要从它的窗口系统得到什么，而不是定义针对窗口系统所有用途的通用接口。

我们通过尽可能的去除假设条件来提高这个算法的通用性。

我们正在开发一种原型，并且正在使用函数本身作为设计工具。其实我们总是可以在完成之后再写规范。

折半查找算法的关键是能够快速计算指向某个序列中间元素的指针。如果这个计算需要便利序列的所有元素，那么折半查找的全部意义都将丧失。

继承是关联类型的一种方法，但是迭代器不属于类型的范畴。相反，它们是一系列类型应该满足或者不应该满足的需求的集合，怎么能用继承关联它们呢？


我们清楚了算法构造中十分重要的一点：当我们反转某个算法的方向时，并不能总是精确地保持原有的对称性。

函数对象配接器所解决的问题之一，是把信息从使用该函数对象的部分通过程序的另一部分传递到第三部分，在第三部分，信息被取出来。

c++函数的总存储空间在程序执行之前就固定了。一旦程序开始运行，就无法创建新函数。

困难在于我们的compose函数想要创建新函数，而C++不允许直接这么做。无论何时面对这样一个问题时，我们都应该考虑用一个类对象来表示这种解决方案。如果compose不能返回一个函数，那么它可能返回一个行为和函数类似的类对象。这样的对象叫做函数对象。

模版实现了类型隐藏。

库设计就是语言设计，语言设计就是库设计

通过私有化复制构造函数和赋值操作符来规定不能复制。

通过返回一个指向data的指针，这个类暴露了3个漏洞：
1.用户可以获得一个指针，然后用它修改保存在data中的字符。这就意味着String类没有真正控制它自己的资源。
2.释放String时，它所占用的内存也被释放。因此，任何指向String到指针都会失效。我们当然可以说任何指针都有同样的问题，用户必须意识到这些问题。
3.我们决定通过释放和重新分配目标String使用的内存来将一个String的赋值实现为另一个。这就是说这样的赋值可能会导致任何指向String内部的指针实效。

为了使表现形式保持简单，我们令缺省构造函数指到一个空字符串上。

必须把判断力，技巧和品味结合起来使用，从而驾驭这种力量，这一点十分重要。

设计一个好程序库的要求之一就是彻底隔离接口和实现

构造函数提供了一种基本方法，将用户看待对象的方式与对象的实际表示方式解耦。

另一个重要的思想，就是能够防止用户访问那些他们不应该看到的类成员。

解决形式冲突

操纵器，以某种方式作用于由它的参数所表示的数据。
应用器，是一个重载操作符，它的操作数是一个可操纵的值和一个将作用于这个值的操纵器。

做理解的事情，理解要做的事情。
逐步加深扩展理解。

三个建议：
1.避免使用指针
2.提倡使用程序库
3.使用类来表示概念

所谓面向对象编程，就是使用继承和动态绑定机制编程。
