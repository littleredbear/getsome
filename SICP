
如果说艺术解释了我们的梦想，那么计算机就是以程序的名义执行着它们。
通过创建抽象去控制复杂性。
数学为精确处理“是什么”提供了一种框架，而计算机则为精确处理“怎样做”的概念提供了一种框架。

当我们描述一个语言时，就需要将注意力特别放在这一语言所提供的，能够将简单的认识组合起来形成更复杂认识的方法方面。每一种强有力的语言都为此提供了三种机制：
1.基本表达形式，用于表示语言所关心的最简单的个体。
2.组合的方法，通过它们可以从较简单的东西出发构造出复合的元素。
3.抽象的方法，通过它们可以为复合对象命名，并将它们当做单元去操作。

在程序设计中，我们需要处理两类要素：过程和数据（它们实际上并不是这样严格分离的）。
非形式地说，数据是一种我们希望去操作的“东西”，而过程就是有关操作这些数据的规则的描述。
这样，任何强有力的程序设计语言都必须能表述基本的数据和基本的过程，还需要提供对过程和数据进行组合和抽象的方法。

define是我们所用的语言里最简单的抽象方法，它允许我们用一个简单的名字去引用一个组合运算的结果。

应该看到，我们可以将值与符号关联，而后又能提取出这些值，这意味着解释器必须维护某种存储能力，以便保持有关的名字－值对偶的轨迹。这种存储被称为环境。

上面描述的这种计算过程被称为过程应用的代换模型。
完全展开而后归约的求值模型称为正则序求值。
先求值参数而后应用的方式，称为应用序求值。

我们用术语谓词指那些返回真或假的过程，也指那种能求出真或者假的值的表达式。

这种类型的计算过程由一个推迟执行的运算链条刻画，称为一个递归计算过程。
与之相对应，第二个计算过程里并没有任何增长或者收缩。对于任何一个n，在计算过程中的每一步，在我们需要保存轨迹里，所有的东西就是变量的当前值。我们称这种过程为一个迭代计算过程。

当我们说一个过程是递归的时候，论述的是一个语法形式上的事实，说明这个过程的定义中引用了该过程本身。

人们对功能强大的程序设计语言有一个必然要求，就是能为公共的模式命名，建立抽象，而后直接在抽象的层次上工作。过程提供了这种能力，这也是为什么除最简单的程序语言外，其他语言都包含定义过程的机制的原因。

过程参数

一般而言，数据抽象的基本思想就是为每一类数据对象标识出一组操作，使得对这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只使用它们。

如果觉得将序对表示为过程还不足以令人如雷灌顶，那么请考虑，在一个可以对过程做各种操作的语言里，我们完全可以没有数，可以将0和加1操作实现为：（define zero (lambda (f) (lambda (x) x)))		(define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x)))))
直观的说lambda演算中的数字n就是一个把函数f作为参数并以f的n次幂为返回值的函数。

一般说，某种组合数据对象的操作满足闭包性质，那就是说，通过它组合起数据对象得到的结果本身还可以通过同样的操作再进行组合。

map是处理序列的一种强有力抽象，与此类似，map与递归的结合也是处理树的一种强有力抽象。

信号流结构
将程序表示为一些针对序列的操作，这样做的价值就在于能帮助我们得到模块化的程序设计，也就是说，得到由一些比较独立的片段的组合构成的设计。

应该用最简单的方式去实现某个功能，在需要的时候做形式转换。

其实所有的数据结构都是类似一个盒子，有有限个入口和特定的格式，根据入口和格式查找剩余的元素。
采用变长编码有一个困难，那就是在读0/1序列的过程中确定何时到达了一个字符的结束。
莫尔斯码解决这一问题的方式是在每个字母的点划序列之后用一个特殊的分隔符。另一个解决方式是以某种方式设计编码，使得其中每个字符的完整编码都不是另一个字符编码的开始一段（或称前缀）。

数据抽象，这是一种构造系统的方法学，采用这种方法，将使一个程序中的大部分描述能与这一程序所操作的数据对象的具体表示的选择无关。
这里的关键性思想就是构筑起一道抽象屏障－对于上面情况，也就是有理数的选择函数和构造函数。

事实上，我们正是在处理一个二维表格，其中的一个维上包含着所有的可能操作，另一个维就是所有的可能类型。
数据导向的程序设计就是一种使程序能直接利用这种表格工作的程序设计技术。
使用数据导向，在后面加入的代码不用修改之前的代码。

处理跨类型操作的一种方式，就是为每一种类型组合的合法运算设计一个特定的过程。
最一般的情况是需要处理针对一批完全无关的类型的一批完全无关的操作，直接实现跨类型操作很可能就是解决问题的最好方式了。

类型塔层次结构

有一种非常强有力的设计策略，特别适合用于构造那类模拟真实物理系统的程序，那就是基于被模拟系统的结构去设计程序的结构。

很大程度上，组织大型程序的方式会受到我们对于被模拟系统的认识的支配。
第一种策略将注意力集中在对象上，将一个大型系统看成一大批对象，它们的行为可能随着时间的进展而不断变化。
另一种组织策略将注意力集中在流过系统的信息流上，非常像电子工程师观察一个信号处理系统。

不用任何赋值的程序设计称为函数式程序设计。
广泛采用赋值的程序设计称为命令式程序设计。

一般而言，带有赋值的程序将强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本。在函数式程序设计中，这类问题根本就不会出现。如果考虑有着多个并发执行的进程的应用程序，命令式程序设计的复杂性还会变得更糟糕。

在求值的环境模型里，一个过程总是一个对偶，由一些代码和一个指向环境的指针组成。
过程只能通过一种方式创建，那就是通过求值一个lambda表达式。这样产生出的过程的代码来自这一lambda表达式的正文，其环境就是求值这个lambda表达式，产生出这个过程时的那个环境。

这里应注意的要点是，对于square的每个调用都会创建起一个包含着x的约束的新环境。
还请注意，由square创建的每个框架都指向全局环境，因为这就是对应于square的过程对象所指定的环境。

环境模型已经解释清楚了以局部过程定义作为程序模块化的有用技术中的两个关键性质：
1.局部过程的名字不会与包容它们的过程之外的名字相互干扰，这是因为这些局部过程名都是在该过程运行时创建的框架里面约束的，而不是在全局环境里约束的。
2.局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数。这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属。

定义了改变函数的数据对象称为变动数据对象。
序对作为构造复合数据的通用“粘结剂”。

利用共享结构可以极大地扩展能够用序对表示的数据结构的范围。在另一方面，共享也可能带来危险，因为对这种结构的修改将会影响那些恰好共享着被修改了的序对的结构。

从理论上说，为了表现变动数据的行为，所需要的全部东西也就是赋值。只要将赋值纳入这一语言，我们就引出了所有的问题，不仅是赋值，而且也包括一般性的变动对象。

按照数据抽象的说法，队列可以看作是由下面一组操作定义的结构。

我们要描绘一种语言的设计，这种语言将使我们可以基于各种关系进行工作。这一语言里的基本元素就是基本约束，它们描述了在不同量之间的某种特定关系。我们将通过构造约束网络的方式组合起各种约束，在这种约束网络里，约束通过连接器连接起来。
使用结构的目的就是为了方面计算，也就是计算模型。

 连接器

采用具有局部状态的对象建立模型，就会迫使我们去直面时间问题，并将它作为程序设计中一个必不可少的概念。

对于并发的一种可能限制方式是规定，修改任意共享状态变量的两个操作都不允许同时发生。
对于并发的另一种不那么严厉的限制方式是，保证并发系统产生出的结果与各个进程按照某种方式顺序进行产生出的结果完全一样。

我们已经看到了处理并发进程的困难，这些困难的根源就在于需要考虑不同进程里各个事件之间交错的情况。检查是否每种排列的行为都是可以接受的。当进程和事件的数量进一步增加时，这一方式很快就会变得无法控制了。
另一种更实际的方法是，在设计并发系统时，设法做出一些一般性的机制，使我们可能限制并行进程之间的交错情况，以保证程序具有正确的行为方式。

串行化就是实现下面的想法：使进程可以并发地执行，但是其中也有一些过程不能并发地执行。说得更准确些，串行化就是创建一些不同的过程集合，并且保证在每个时刻，在任何一个串行化集合里至多只有一个过程的一个执行。
举例说，如果我们希望基于某个共享变量已有的值去更新它，那么就应该将访问这一变量的现有值和给这一变量赋新值的操作都放入同一个过程里。而后设法保证，任何能给这个变量赋值的过程都不会与这个过程并发运行，方法是将所有这样的过程都放在同一个串行化集合里。

并发性的基本问题比这些更深刻，因为，从一种更基本的观点看，“共享状态”究竟意味着什么，这件事常常并不清楚。

代替串行化的另一种方式是屏障同步。程序猿可以允许并发进程随意地执行，但需要建立起一些同步点（“屏障”），任何进程在所有进程没有到达这里之前都不能穿过它。

如果以数学函数的方式考虑这些问题，我们可以将一个量x的随着时间而变化的行为，描述为一个时间的函数x(t)。如果我们想集中关注的是一个个时刻的x，那么就可以将它看作一个变化着的量。
如果用离散的步长去度量时间，那么我们就可以用一个序列去模拟一个时间函数。从抽象的观点看，一个流也就是一个序列。

这里的基本想法就是做出一种安排，只是部分地构造出流的结构，并将这样的部份结构送给使用流的程序。如果使用者需要访问这个流的尚未构造出的那个部分，那么这个流就会自动地继续构造下去，但是只做出足够满足当时需要的那一部分。

厄拉多塞筛法：从整数2开始，从其余的整数中过滤掉2的所有倍数。到3，再过滤掉所有3的倍数。。。

如果不使用流，我们也可以实现这些加速技术，但流的描述形式特别优美而又方便，因为整个状态序列就像一个数据结构一样，可以通过一集统一的操作直接地随意使用。

引进赋值和变动对象，就是为了提供一种机制，以便能模块化地构造出程序，去模拟具有状态的系统。
当输入参数是流，输出也会是流
正是由于用户方的时态的存在，为这个系统赋予了状态特性。

用对象来做模拟是威力强大的，也很直观，这一情况的主要根源，就在于它非常符合我们对自己身处其中并与之交流的世界的看法。

事实上，我们几乎可以把任何程序看做是某个语言的求值器。
而计算机科学本身不过（也不更少）就是有关如何构造适当的描述语言的学科。

用与被求值的语言同样的语言写出来的求值器被称为元循环。

在思考求值Lisp表达式的Lisp程序时，有一个类比可能很有帮助。
更一般地说，在块结构里，一个局部名字的作用域，应该是相应define的求值所在的整个过程体。

发明新的语言，常常就是先用一种现有的高级程序设计语言写出一个嵌入了这个新语言的求值器。
惰性求值的一个优点就是使某些过程能够完成有用的计算，即使对它们的某些参数的求值将产生错误甚至根本不能终止。
如果在某个参数还没有完成求值之前就进入一个过程体，我们就说这一过程相对于该参数是非严格的。
如果在进入过程体之前某个参数已经完成求值，我们就说该过程相对于这个参数为严格的。
